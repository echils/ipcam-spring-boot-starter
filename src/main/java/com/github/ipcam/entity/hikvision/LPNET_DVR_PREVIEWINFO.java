package com.github.ipcam.entity.hikvision;


import com.github.ipcam.entity.comm.STRUCTURE_CONTEXT;
import com.github.ipcam.entity.jnax.W32API;
import com.sun.jna.Structure;

/**
 * LPNET_DVR_PREVIEWINFO
 *
 * @author echils
 * @since 2020-03-19 13:42
 */
public class LPNET_DVR_PREVIEWINFO extends Structure {

    /**
     * Channel number, currently the analog channel number of the device starts from 1,
     * and the initial channel number of the digital channel is obtained through NET_DVR_GetDVRConfig
     * (configuration command NET_DVR_GET_IPPARACFG_V40) (dwStartDChan).
     */
    public int lChannel;

    /**
     * Type of stream: 0- primary stream, 1- substream, 2- three stream, 3- virtual stream, and so on
     */
    public int dwStreamType;

    /**
     * Connection mode: 0-TCP, 1-UDP, 2-Multicast, 3-RTP, 4-RTP /RTSP,
     * 5-RTP /HTTP, 6-HRUDP (reliable transmission), 7-RTSP /HTTPS, 8-NPQ
     */
    public int dwLinkMode;

    /**
     * Handle to the playback window. NULL indicates undecoded display.
     */
    public W32API.HWND hPlayWnd;

    /**
     * 0- non-blocking fetching, 1- blocking fetching
     * If it is set to non-blocking, it means that the connection with the device is considered to be successful.
     * If the code stream fails to receive or play fails, the upper layer will be notified in the way of preview exception.
     * The pause time can be reduced during loop play, in line with the NET_DVR_RealPlay processing.
     * If set to block, it means that the return is successful or not until the play operation is completed.
     * When the network is abnormal, SDK internal connect fails, and there will be a 5S timeout before the return,
     * which is not suitable for the polling fetch stream operation.
     */
    public boolean bBlocked;

    /**
     * Enable video playback: 0- Disable video playback, 1- Enable video playback. ANR network disconnection and
     * supplement function, the front-end data will be automatically synchronized after the abnormal network recovery
     * between the client and the device, which requires the support of the device.
     */
    public boolean bPassbackRecord;

    /**
     * Delayed preview mode: 0- normal preview, 1- delayed preview
     */
    public byte byPreviewMode;

    /**
     * Stream ID, which is a combination of letters, numbers, and "_". Enable when LChannel is 0xFFFFFFFF
     */
    public byte[] byStreamID = new byte[STRUCTURE_CONTEXT.STREAM_ID_LEN];

    /**
     * Application layer fetching protocol: 0- private protocol, 1- RTSP protocol. The fetching protocol supported by
     * the master and child codestreams is known by byMainProto and bySubProto, which return the structure parameter
     * NET_DVR_DEVICEINFO_V30 via login. This parameter is only valid if the device supports both private and RTSP protocols.
     * The default protocol is private, and the RTSP protocol is optional
     */
    public byte byProtoType;

    /**
     * Keep it, set it to 0
     */
    public byte byRes1;

    /**
     * Type of code stream data encoding and decoding: 0-general coded data, 1-raw data generated by thermal imaging
     * detector (encryption information of temperature data, and the original data can be calculated to the real temperature
     * value through de-encryption operation)
     */
    public byte byVideoCodingType;

    /**
     * The maximum number of frames in the playback buffer of the playback library, with the range of values:
     * 1, 6 (default, adaptive playback mode), 15, and 1 when set to 0
     */
    public int dwDisplayBufNum;

    /**
     * Keep it, set it to 0
     */
    public byte[] byRes = new byte[216];

}